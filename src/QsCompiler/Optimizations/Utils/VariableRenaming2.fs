// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

namespace Microsoft.Quantum.QsCompiler.ExperimentalNew

open System
open System.Text.RegularExpressions
open Microsoft.Quantum.QsCompiler.Experimental.Utils
open Microsoft.Quantum.QsCompiler.SyntaxTokens
open Microsoft.Quantum.QsCompiler.SyntaxTree
open Microsoft.Quantum.QsCompiler.Transformations.Core


/// The ScopeTransformation used to ensure unique variable names.
/// When called on a function body, will transform it such that all local variables defined
/// in the function body have unique names, generating new variable names if needed.
/// Autogenerated variable names have the form __qsVar[X]__[name]__.
type VariableRenaming () =
    inherit MonoTransformation()

    /// <summary>
    /// Returns a copy of the given variable stack with the given key set to the given value.
    /// </summary>
    /// <exception cref="ArgumentException">The given variable stack is empty.</exception>
    let set (key, value) =
        function
        | [] -> ArgumentException "No scope to define variables in" |> raise
        | head :: tail -> Map.add key value head :: tail

    /// A regex that matches the original name of a mangled variable name
    let varNameRegex = Regex("^__qsVar\d+__(.+)__$")

    /// Given a possibly-mangled variable name, returns the original variable name
    let demangle varName =
        let m = varNameRegex.Match varName
        if m.Success then m.Groups.[1].Value else varName

    /// Returns the value associated to the given key in the given variable stack.
    /// If the key is associated with multiple values, returns the one highest on the stack.
    /// Returns None if the key isn't associated with any values.
    let tryGet key = List.tryPick (Map.tryFind key)

    /// Processes the initial argument tuple from the function declaration
    member private this.ProcessArgTuple =
        function
        | QsTupleItem { VariableName = ValidName name } -> this.GenerateUniqueName name |> ignore
        | QsTupleItem { VariableName = InvalidName } -> ()
        | QsTuple items -> Seq.iter this.ProcessArgTuple items

    /// The number of times a variable is referenced
    member val internal NewNamesSet = Set.empty with get, set
    /// The current dictionary of new names to substitute for variables
    member val internal RenamingStack = [ Map.empty ] with get, set
    /// Whether we should skip entering the next scope we encounter
    member val internal SkipScope = false with get, set

    /// Returns a copy of the given variable stack inside of a new scope
    member internal this.EnterScope map = Map.empty :: map

    /// <summary>
    /// Returns a copy of the given variable stack outside of the current scope.
    /// </summary>
    /// <exception cref="ArgumentException">The given variable stack is empty.</exception>
    member internal this.ExitScope = List.tail

    /// Given a new variable name, generates a new unique name and updates the state accordingly
    member this.GenerateUniqueName varName =
        let baseName = demangle varName
        let mutable num, newName = 0, baseName

        while this.NewNamesSet.Contains newName do
            num <- num + 1
            newName <- sprintf "__qsVar%d__%s__" num baseName

        this.NewNamesSet <- this.NewNamesSet.Add newName
        this.RenamingStack <- set (varName, newName) this.RenamingStack
        newName

    member this.Clear() =
        this.NewNamesSet <- Set.empty
        this.RenamingStack <- [ Map.empty ]

    override this.OnLocalNameDeclaration name = this.GenerateUniqueName name

    override this.OnLocalName name =
        maybe { return! tryGet name this.RenamingStack } |? name

    override __.OnArgumentTuple argTuple = argTuple

    override this.OnProvidedImplementation(argTuple, body) =
        this.Clear()
        do this.ProcessArgTuple argTuple
        ``base``.OnProvidedImplementation(argTuple, body)

    override this.OnScope x =
        if this.SkipScope then
            this.SkipScope <- false
            base.OnScope x
        else
            this.RenamingStack <- this.EnterScope this.RenamingStack
            let result = base.OnScope x
            this.RenamingStack <- this.ExitScope this.RenamingStack
            result

    override this.OnRepeatStatement stm =
        this.RenamingStack <- this.EnterScope this.RenamingStack
        this.SkipScope <- true

        let result = base.OnRepeatStatement stm
        this.RenamingStack <- this.ExitScope this.RenamingStack
        result
